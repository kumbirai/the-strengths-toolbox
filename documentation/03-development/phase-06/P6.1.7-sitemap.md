# P6.1.7 XML Sitemap Implementation Plan

## 1. Overview and Objectives

### 1.1 Purpose
This document provides detailed step-by-step instructions for implementing XML sitemap generation for The Strengths Toolbox website. The sitemap will help search engines discover and index all pages, blog posts, and content.

### 1.2 Scope
This implementation plan covers task P6.1.7:
- **P6.1.7**: Generate XML sitemap
  - Create SitemapController
  - Generate sitemap with all published pages
  - Generate sitemap with all published blog posts
  - Include static pages
  - Set proper priorities and change frequencies
  - Add sitemap route
  - Implement sitemap caching

### 1.3 Success Criteria
- XML sitemap accessible at `/sitemap.xml`
- All published pages included in sitemap
- All published blog posts included in sitemap
- Static pages included in sitemap
- Proper priorities and change frequencies set
- Sitemap validates with XML validators
- Sitemap is cached for performance
- Sitemap updates when content changes

## 2. Prerequisites

### 2.1 Required Knowledge
- XML sitemap protocol
- Sitemap XML schema
- Laravel controllers and routing
- Caching strategies

### 2.2 Dependencies
- Task P2.1.1 completed (PageService created)
- Task P2.1.2 completed (BlogPostService created)
- All pages and blog posts from Phase 4 and 5
- CacheService from Phase 2

### 2.3 Reference Documents
- SEO Architecture: `documentation/01-architecture/05-seo-architecture.md`
- Sitemap Protocol: https://www.sitemaps.org/protocol.html
- Google Sitemap Guidelines: https://developers.google.com/search/docs/crawling-indexing/sitemaps/overview

## 3. Existing Implementation Review

### 3.1 Current State
- No sitemap implementation exists
- Routes are defined in `routes/web.php`
- Page and BlogPost models exist with published scopes
- CacheService exists for caching

### 3.2 What Needs to Be Built
- SitemapController to generate XML sitemap
- Sitemap view/template for XML output
- Route for sitemap access
- Caching mechanism for sitemap
- Cache invalidation when content changes

## 4. Task P6.1.7: Generate XML Sitemap

### 4.1 Overview
Create a dynamic XML sitemap that includes all published pages, blog posts, and static pages with appropriate priorities and change frequencies.

### 4.2 Step-by-Step Implementation

#### Step 1: Create SitemapController

**File: `app/Http/Controllers/SitemapController.php`**

```php
<?php

namespace App\Http\Controllers;

use App\Models\Page;
use App\Models\BlogPost;
use App\Services\PageService;
use App\Services\BlogPostService;
use Illuminate\Http\Response;
use Illuminate\Support\Facades\Cache;

class SitemapController extends Controller
{
    protected PageService $pageService;
    protected BlogPostService $blogPostService;
    protected int $cacheTtl;

    public function __construct(PageService $pageService, BlogPostService $blogPostService)
    {
        $this->pageService = $pageService;
        $this->blogPostService = $blogPostService;
        $this->cacheTtl = config('cache.ttl.sitemap', 3600); // 1 hour
    }

    /**
     * Generate and return XML sitemap
     *
     * @return Response
     */
    public function index(): Response
    {
        $sitemap = Cache::remember('sitemap.xml', $this->cacheTtl, function () {
            return $this->generateSitemap();
        });

        return response($sitemap, 200)
            ->header('Content-Type', 'application/xml; charset=utf-8');
    }

    /**
     * Generate sitemap XML content
     *
     * @return string
     */
    protected function generateSitemap(): string
    {
        $urls = [];

        // Homepage
        $urls[] = [
            'loc' => url('/'),
            'lastmod' => now()->toAtomString(),
            'changefreq' => 'weekly',
            'priority' => '1.0',
        ];

        // Static pages
        $staticPages = [
            ['url' => route('about'), 'priority' => '0.9', 'changefreq' => 'monthly'],
            ['url' => route('strengths-programme'), 'priority' => '0.9', 'changefreq' => 'monthly'],
            ['url' => route('contact'), 'priority' => '0.8', 'changefreq' => 'monthly'],
            ['url' => route('booking'), 'priority' => '0.8', 'changefreq' => 'monthly'],
            ['url' => route('blog.index'), 'priority' => '0.9', 'changefreq' => 'daily'],
            ['url' => route('testimonials'), 'priority' => '0.7', 'changefreq' => 'monthly'],
            ['url' => route('books'), 'priority' => '0.7', 'changefreq' => 'monthly'],
            ['url' => route('keynote-talks'), 'priority' => '0.7', 'changefreq' => 'monthly'],
            ['url' => route('privacy'), 'priority' => '0.5', 'changefreq' => 'yearly'],
        ];

        foreach ($staticPages as $page) {
            $urls[] = [
                'loc' => $page['url'],
                'lastmod' => now()->toAtomString(),
                'changefreq' => $page['changefreq'],
                'priority' => $page['priority'],
            ];
        }

        // Published pages from CMS
        $pages = Page::where('is_published', true)
            ->whereNotNull('published_at')
            ->where('published_at', '<=', now())
            ->orderBy('updated_at', 'desc')
            ->get();

        foreach ($pages as $page) {
            // Skip if page is already in static pages
            $pageUrl = url('/' . $page->slug);
            $isStatic = collect($staticPages)->contains(function ($static) use ($pageUrl) {
                return $static['url'] === $pageUrl;
            });

            if (!$isStatic) {
                $urls[] = [
                    'loc' => $pageUrl,
                    'lastmod' => $page->updated_at->toAtomString(),
                    'changefreq' => $this->determineChangeFreq($page->updated_at),
                    'priority' => '0.8',
                ];
            }
        }

        // Published blog posts
        $posts = BlogPost::where('is_published', true)
            ->whereNotNull('published_at')
            ->where('published_at', '<=', now())
            ->orderBy('published_at', 'desc')
            ->get();

        foreach ($posts as $post) {
            $urls[] = [
                'loc' => route('blog.show', $post->slug),
                'lastmod' => $post->updated_at->toAtomString(),
                'changefreq' => $this->determineChangeFreq($post->updated_at),
                'priority' => '0.7',
            ];
        }

        // Blog categories
        $categories = \App\Models\Category::has('blogPosts')->get();
        foreach ($categories as $category) {
            $urls[] = [
                'loc' => route('blog.category', $category->slug),
                'lastmod' => $category->updated_at->toAtomString(),
                'changefreq' => 'weekly',
                'priority' => '0.6',
            ];
        }

        // Blog tags (optional - can be excluded if too many)
        // Uncomment if you want tags in sitemap
        /*
        $tags = \App\Models\Tag::has('blogPosts')->limit(50)->get();
        foreach ($tags as $tag) {
            $urls[] = [
                'loc' => route('blog.tag', $tag->slug),
                'lastmod' => $tag->updated_at->toAtomString(),
                'changefreq' => 'weekly',
                'priority' => '0.5',
            ];
        }
        */

        return $this->renderSitemap($urls);
    }

    /**
     * Determine change frequency based on last update
     *
     * @param \Illuminate\Support\Carbon $updatedAt
     * @return string
     */
    protected function determineChangeFreq($updatedAt): string
    {
        $daysSinceUpdate = $updatedAt->diffInDays(now());

        if ($daysSinceUpdate < 7) {
            return 'daily';
        } elseif ($daysSinceUpdate < 30) {
            return 'weekly';
        } elseif ($daysSinceUpdate < 365) {
            return 'monthly';
        } else {
            return 'yearly';
        }
    }

    /**
     * Render sitemap XML
     *
     * @param array $urls
     * @return string
     */
    protected function renderSitemap(array $urls): string
    {
        $xml = '<?xml version="1.0" encoding="UTF-8"?>' . "\n";
        $xml .= '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">' . "\n";

        foreach ($urls as $url) {
            $xml .= "  <url>\n";
            $xml .= "    <loc>" . htmlspecialchars($url['loc'], ENT_XML1, 'UTF-8') . "</loc>\n";
            
            if (isset($url['lastmod'])) {
                $xml .= "    <lastmod>" . htmlspecialchars($url['lastmod'], ENT_XML1, 'UTF-8') . "</lastmod>\n";
            }
            
            if (isset($url['changefreq'])) {
                $xml .= "    <changefreq>" . htmlspecialchars($url['changefreq'], ENT_XML1, 'UTF-8') . "</changefreq>\n";
            }
            
            if (isset($url['priority'])) {
                $xml .= "    <priority>" . htmlspecialchars($url['priority'], ENT_XML1, 'UTF-8') . "</priority>\n";
            }
            
            $xml .= "  </url>\n";
        }

        $xml .= '</urlset>';

        return $xml;
    }

    /**
     * Clear sitemap cache
     *
     * @return void
     */
    public static function clearCache(): void
    {
        Cache::forget('sitemap.xml');
    }
}
```

#### Step 2: Add Sitemap Route

**File: `routes/web.php`**

**Update required:**
Add sitemap route before the catch-all route:

```php
use App\Http\Controllers\SitemapController;

// Sitemap (before catch-all routes)
Route::get('/sitemap.xml', [SitemapController::class, 'index'])->name('sitemap');

// Dynamic pages (catch-all for CMS pages - must be last)
Route::get('/{slug}', [PageController::class, 'show'])->name('pages.show');
```

#### Step 3: Create Sitemap View (Alternative Approach)

**Note:** If you prefer using a Blade view instead of generating XML in the controller, create this view:

**File: `resources/views/sitemap/index.blade.php`**

```blade
<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
    {{-- Homepage --}}
    <url>
        <loc>{{ config('app.url') }}</loc>
        <lastmod>{{ now()->toAtomString() }}</lastmod>
        <changefreq>weekly</changefreq>
        <priority>1.0</priority>
    </url>

    {{-- Static Pages --}}
    @foreach($staticPages as $page)
    <url>
        <loc>{{ $page['url'] }}</loc>
        <lastmod>{{ $page['lastmod'] }}</lastmod>
        <changefreq>{{ $page['changefreq'] }}</changefreq>
        <priority>{{ $page['priority'] }}</priority>
    </url>
    @endforeach

    {{-- CMS Pages --}}
    @foreach($pages as $page)
    <url>
        <loc>{{ url('/' . $page->slug) }}</loc>
        <lastmod>{{ $page->updated_at->toAtomString() }}</lastmod>
        <changefreq>{{ $changeFreq }}</changefreq>
        <priority>0.8</priority>
    </url>
    @endforeach

    {{-- Blog Posts --}}
    @foreach($posts as $post)
    <url>
        <loc>{{ route('blog.show', $post->slug) }}</loc>
        <lastmod>{{ $post->updated_at->toAtomString() }}</lastmod>
        <changefreq>monthly</changefreq>
        <priority>0.7</priority>
    </url>
    @endforeach

    {{-- Blog Categories --}}
    @foreach($categories as $category)
    <url>
        <loc>{{ route('blog.category', $category->slug) }}</loc>
        <lastmod>{{ $category->updated_at->toAtomString() }}</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.6</priority>
    </url>
    @endforeach
</urlset>
```

**If using view approach, update controller:**
```php
public function index(): Response
{
    $data = Cache::remember('sitemap.data', $this->cacheTtl, function () {
        return $this->getSitemapData();
    });

    $content = view('sitemap.index', $data)->render();

    return response($content, 200)
        ->header('Content-Type', 'application/xml; charset=utf-8');
}
```

#### Step 4: Add Cache Configuration

**File: `config/cache.php`**

**Update required:**
Add sitemap cache TTL if not already present:

```php
'ttl' => [
    'sitemap' => env('CACHE_TTL_SITEMAP', 3600), // 1 hour
    // ... other TTL values
],
```

#### Step 5: Implement Cache Invalidation

**File: `app/Observers/PageObserver.php` (if exists) or create it**

**Purpose:** Clear sitemap cache when pages are updated

```php
<?php

namespace App\Observers;

use App\Models\Page;
use App\Http\Controllers\SitemapController;

class PageObserver
{
    public function created(Page $page): void
    {
        SitemapController::clearCache();
    }

    public function updated(Page $page): void
    {
        SitemapController::clearCache();
    }

    public function deleted(Page $page): void
    {
        SitemapController::clearCache();
    }
}
```

**File: `app/Observers/BlogPostObserver.php` (if exists) or create it**

```php
<?php

namespace App\Observers;

use App\Models\BlogPost;
use App\Http\Controllers\SitemapController;

class BlogPostObserver
{
    public function created(BlogPost $post): void
    {
        SitemapController::clearCache();
    }

    public function updated(BlogPost $post): void
    {
        SitemapController::clearCache();
    }

    public function deleted(BlogPost $post): void
    {
        SitemapController::clearCache();
    }
}
```

**File: `app/Providers/EventServiceProvider.php`**

**Update required:**
Register observers:

```php
use App\Models\Page;
use App\Models\BlogPost;
use App\Observers\PageObserver;
use App\Observers\BlogPostObserver;

public function boot(): void
{
    Page::observe(PageObserver::class);
    BlogPost::observe(BlogPostObserver::class);
}
```

#### Step 6: Add Sitemap Index (Optional - for large sites)

**Note:** If you have more than 50,000 URLs, create a sitemap index that references multiple sitemaps.

**File: `app/Http/Controllers/SitemapIndexController.php`**

```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Response;

class SitemapIndexController extends Controller
{
    public function index(): Response
    {
        $xml = '<?xml version="1.0" encoding="UTF-8"?>' . "\n";
        $xml .= '<sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">' . "\n";
        $xml .= "  <sitemap>\n";
        $xml .= "    <loc>" . route('sitemap') . "</loc>\n";
        $xml .= "    <lastmod>" . now()->toAtomString() . "</lastmod>\n";
        $xml .= "  </sitemap>\n";
        $xml .= '</sitemapindex>';

        return response($xml, 200)
            ->header('Content-Type', 'application/xml; charset=utf-8');
    }
}
```

#### Step 7: Create Artisan Command to Generate Sitemap

**File: `app/Console/Commands/GenerateSitemap.php`**

**Purpose:** Command to manually generate/refresh sitemap

```php
<?php

namespace App\Console\Commands;

use App\Http\Controllers\SitemapController;
use Illuminate\Console\Command;

class GenerateSitemap extends Command
{
    protected $signature = 'sitemap:generate';
    protected $description = 'Generate and cache the XML sitemap';

    public function handle(): int
    {
        $this->info('Generating sitemap...');

        // Clear existing cache
        SitemapController::clearCache();

        // Generate new sitemap (this will cache it)
        $controller = app(SitemapController::class);
        $sitemap = $controller->index();

        $this->info('Sitemap generated successfully!');
        $this->info('Access at: ' . route('sitemap'));

        return 0;
    }
}
```

## 5. Testing Instructions

### 5.1 Manual Testing

1. **Test Sitemap Access:**
   - Visit `/sitemap.xml`
   - Verify XML is returned
   - Verify Content-Type header is `application/xml`

2. **Validate XML Structure:**
   - Check XML is well-formed
   - Verify all required elements are present
   - Verify URLs are absolute and correct

3. **Test URLs in Sitemap:**
   - Check a few URLs from sitemap
   - Verify they are accessible
   - Verify they return 200 status

4. **Test Priorities and Change Frequencies:**
   - Verify homepage has priority 1.0
   - Verify blog posts have appropriate priorities
   - Verify change frequencies are set

### 5.2 Automated Testing

1. **Use XML Validator:**
   - Visit: https://www.xml-sitemaps.com/validate-xml-sitemap.html
   - Enter sitemap URL
   - Verify no errors

2. **Use Google Search Console:**
   - Submit sitemap to Google Search Console
   - Verify no errors reported

3. **Test Cache:**
   - Generate sitemap
   - Update a page
   - Verify cache is cleared
   - Verify sitemap updates

### 5.3 Browser Testing

1. **Test in Browser:**
   - Open `/sitemap.xml` in browser
   - Verify XML displays correctly
   - Verify all URLs are present

2. **Test Cache Headers:**
   - Check response headers
   - Verify appropriate caching headers

## 6. Success Criteria Validation

- [ ] Sitemap accessible at `/sitemap.xml`
- [ ] All published pages included
- [ ] All published blog posts included
- [ ] Static pages included
- [ ] Proper priorities set (homepage 1.0, etc.)
- [ ] Change frequencies set appropriately
- [ ] XML validates correctly
- [ ] Sitemap is cached
- [ ] Cache invalidates on content updates
- [ ] No broken URLs in sitemap

## 7. Notes and Considerations

1. **Sitemap Size:**
   - Maximum 50,000 URLs per sitemap
   - Maximum 50MB file size
   - If exceeded, create sitemap index

2. **Update Frequency:**
   - Update sitemap when content changes
   - Use observers to clear cache automatically
   - Consider scheduled regeneration

3. **Priorities:**
   - Homepage: 1.0
   - Important pages: 0.9
   - Regular pages: 0.8
   - Blog posts: 0.7
   - Archive pages: 0.6
   - Less important: 0.5

4. **Change Frequencies:**
   - Always: Never use (not valid)
   - Hourly: For frequently updated content
   - Daily: For blog posts, news
   - Weekly: For regular pages
   - Monthly: For static content
   - Yearly: For rarely updated content
   - Never: For archived content

5. **URL Format:**
   - Use absolute URLs
   - Use HTTPS in production
   - Include trailing slashes consistently

6. **Future Enhancements:**
   - Add image sitemap for images
   - Add video sitemap if videos are added
   - Add news sitemap for news articles
   - Implement sitemap compression (gzip)

---

**Document Version:** 1.0  
**Date Created:** 2025-01-27  
**Status:** Ready for Implementation
