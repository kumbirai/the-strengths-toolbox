# P6.2.4 Database Query Optimization Implementation Plan

## 1. Overview and Objectives

### 1.1 Purpose
This document provides detailed step-by-step instructions for optimizing database queries in The Strengths Toolbox website to improve performance and reduce load times.

### 1.2 Scope
This implementation plan covers task P6.2.4:
- **P6.2.4**: Optimize database queries
  - Identify N+1 query problems
  - Implement eager loading
  - Add database indexes
  - Optimize query selections
  - Implement query result caching
  - Review and optimize slow queries

### 1.3 Success Criteria
- No N+1 query problems
- All relationships eager loaded where needed
- Appropriate indexes on frequently queried columns
- Queries select only needed columns
- Query result caching implemented
- Database query performance improved

## 2. Prerequisites

### 2.1 Required Knowledge
- Laravel Eloquent ORM
- Database indexing
- Query optimization techniques
- Eager loading patterns

### 2.2 Dependencies
- Database models and relationships defined
- Database migrations created
- Query logging enabled for analysis

### 2.3 Reference Documents
- Performance Architecture: `documentation/01-architecture/07-performance-optimization-architecture.md`
- Database Architecture: `documentation/01-architecture/03-database-architecture.md`

## 3. Existing Implementation Review

### 3.1 Current State
- Models with relationships defined
- Some eager loading in services
- Basic query result caching
- May have N+1 query issues

### 3.2 What Needs to Be Done
- Audit all queries for N+1 problems
- Add eager loading where missing
- Review and add database indexes
- Optimize query selections
- Enhance query result caching

## 4. Task P6.2.4: Optimize Database Queries

### 4.1 Overview
Systematically review and optimize all database queries to eliminate N+1 problems, add indexes, and improve query performance.

### 4.2 Step-by-Step Implementation

#### Step 1: Enable Query Logging

**File: `app/Providers/AppServiceProvider.php`**

**Update required:**
```php
public function boot(): void
{
    if (app()->environment('local')) {
        \DB::listen(function ($query) {
            \Log::info($query->sql);
            \Log::info($query->bindings);
            \Log::info($query->time);
        });
    }
}
```

#### Step 2: Create Query Analysis Command

**File: `app/Console/Commands/AnalyzeQueries.php`**

```php
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;

class AnalyzeQueries extends Command
{
    protected $signature = 'db:analyze-queries';
    protected $description = 'Analyze database queries for optimization opportunities';

    public function handle(): int
    {
        $this->info('Analyzing database queries...');
        
        // Enable query logging
        DB::enableQueryLog();
        
        // Simulate common page loads
        $this->info('Simulating homepage load...');
        app(\App\Http\Controllers\Web\HomeController::class)->index();
        
        $this->info('Simulating blog listing...');
        app(\App\Http\Controllers\Web\BlogController::class)->index(request());
        
        $this->info('Simulating page load...');
        $pageController = app(\App\Http\Controllers\Web\PageController::class);
        $pageController->show(request(), 'about-us');
        
        // Get queries
        $queries = DB::getQueryLog();
        
        $this->newLine();
        $this->info("Total queries: " . count($queries));
        $this->newLine();
        
        // Analyze for N+1 problems
        $this->analyzeNPlusOne($queries);
        
        // Show slow queries
        $this->showSlowQueries($queries);
        
        return 0;
    }
    
    protected function analyzeNPlusOne(array $queries): void
    {
        $this->info('Analyzing for N+1 query problems...');
        
        // Group queries by table
        $queriesByTable = [];
        foreach ($queries as $query) {
            if (preg_match('/from `?(\w+)`?/i', $query['query'], $matches)) {
                $table = $matches[1];
                $queriesByTable[$table] = ($queriesByTable[$table] ?? 0) + 1;
            }
        }
        
        // Find tables with many queries (potential N+1)
        foreach ($queriesByTable as $table => $count) {
            if ($count > 10) {
                $this->warn("Potential N+1 problem: {$table} queried {$count} times");
            }
        }
    }
    
    protected function showSlowQueries(array $queries): void
    {
        $this->info('Slow queries (>100ms):');
        
        $slowQueries = array_filter($queries, fn($q) => $q['time'] > 100);
        
        if (empty($slowQueries)) {
            $this->info('No slow queries found!');
            return;
        }
        
        foreach ($slowQueries as $query) {
            $this->line("Time: {$query['time']}ms");
            $this->line("Query: {$query['query']}");
            $this->newLine();
        }
    }
}
```

#### Step 3: Review and Fix N+1 Queries

**Files to review:**
- `app/Http/Controllers/Web/BlogController.php`
- `app/Http/Controllers/Web/PageController.php`
- `app/Services/BlogPostService.php`
- `app/Services/PageService.php`

**Action:** Add eager loading for relationships:

```php
// Before (N+1 problem)
$posts = BlogPost::where('is_published', true)->get();
foreach ($posts as $post) {
    echo $post->author->name; // Query for each post
    echo $post->categories->count(); // Query for each post
}

// After (Eager loading)
$posts = BlogPost::with(['author', 'categories', 'tags'])
    ->where('is_published', true)
    ->get();
foreach ($posts as $post) {
    echo $post->author->name; // No additional query
    echo $post->categories->count(); // No additional query
}
```

#### Step 4: Add Database Indexes

**File: `database/migrations/YYYY_MM_DD_HHMMSS_add_performance_indexes.php`**

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        // Pages table indexes
        Schema::table('pages', function (Blueprint $table) {
            if (!$this->hasIndex('pages', 'slug')) {
                $table->index('slug');
            }
            if (!$this->hasIndex('pages', 'is_published')) {
                $table->index('is_published');
            }
            if (!$this->hasIndex('pages', 'published_at')) {
                $table->index('published_at');
            }
            // Composite index for common query
            if (!$this->hasIndex('pages', 'is_published_published_at')) {
                $table->index(['is_published', 'published_at']);
            }
        });

        // Blog posts table indexes
        Schema::table('blog_posts', function (Blueprint $table) {
            if (!$this->hasIndex('blog_posts', 'slug')) {
                $table->index('slug');
            }
            if (!$this->hasIndex('blog_posts', 'is_published')) {
                $table->index('is_published');
            }
            if (!$this->hasIndex('blog_posts', 'published_at')) {
                $table->index('published_at');
            }
            if (!$this->hasIndex('blog_posts', 'author_id')) {
                $table->index('author_id');
            }
            // Composite index
            if (!$this->hasIndex('blog_posts', 'is_published_published_at')) {
                $table->index(['is_published', 'published_at']);
            }
        });

        // Categories table indexes
        Schema::table('categories', function (Blueprint $table) {
            if (!$this->hasIndex('categories', 'slug')) {
                $table->index('slug');
            }
        });

        // Tags table indexes
        Schema::table('tags', function (Blueprint $table) {
            if (!$this->hasIndex('tags', 'slug')) {
                $table->index('slug');
            }
        });
    }

    public function down(): void
    {
        Schema::table('pages', function (Blueprint $table) {
            $table->dropIndex(['slug']);
            $table->dropIndex(['is_published']);
            $table->dropIndex(['published_at']);
            $table->dropIndex(['is_published', 'published_at']);
        });

        Schema::table('blog_posts', function (Blueprint $table) {
            $table->dropIndex(['slug']);
            $table->dropIndex(['is_published']);
            $table->dropIndex(['published_at']);
            $table->dropIndex(['author_id']);
            $table->dropIndex(['is_published', 'published_at']);
        });

        Schema::table('categories', function (Blueprint $table) {
            $table->dropIndex(['slug']);
        });

        Schema::table('tags', function (Blueprint $table) {
            $table->dropIndex(['slug']);
        });
    }

    protected function hasIndex(string $table, string $index): bool
    {
        $indexes = Schema::getConnection()
            ->getDoctrineSchemaManager()
            ->listTableIndexes($table);
        
        return isset($indexes[$index]);
    }
};
```

#### Step 5: Optimize Query Selections

**Update services to select only needed columns:**

```php
// Before
$pages = Page::all();

// After
$pages = Page::select('id', 'title', 'slug', 'excerpt', 'published_at')
    ->where('is_published', true)
    ->get();
```

#### Step 6: Enhance Query Result Caching

**File: `app/Services/PageService.php`**

**Update required:**
Ensure all queries are cached appropriately:

```php
public function getBySlug(string $slug): ?Page
{
    return Cache::remember(
        "page.slug.{$slug}",
        $this->cacheTtl,
        fn() => $this->pageRepository->findPublishedBySlug($slug)
            ->load('seo') // Eager load relationship
    );
}
```

## 5. Testing Instructions

### 5.1 Query Analysis

1. **Run query analysis:**
   ```bash
   php artisan db:analyze-queries
   ```

2. **Review query log:**
   - Check for N+1 problems
   - Identify slow queries
   - Verify eager loading

### 5.2 Performance Testing

1. **Measure before optimization:**
   - Record page load times
   - Count database queries
   - Note slow queries

2. **Measure after optimization:**
   - Compare page load times
   - Compare query counts
   - Verify improvements

## 6. Success Criteria Validation

- [ ] No N+1 query problems identified
- [ ] All relationships eager loaded
- [ ] Indexes added to frequently queried columns
- [ ] Queries select only needed columns
- [ ] Query result caching working
- [ ] Database performance improved

## 7. Notes and Considerations

1. **Index Strategy:**
   - Index foreign keys
   - Index frequently filtered columns
   - Index columns used in WHERE clauses
   - Don't over-index (slows writes)

2. **Eager Loading:**
   - Use `with()` for known relationships
   - Use `load()` for conditional loading
   - Avoid loading unnecessary relationships

3. **Query Caching:**
   - Cache expensive queries
   - Set appropriate TTL
   - Clear cache on updates

---

**Document Version:** 1.0  
**Date Created:** 2025-01-27  
**Status:** Ready for Implementation
