# P7.1.2 OpenAI Integration Implementation Plan

## 1. Overview and Objectives

### 1.1 Purpose
This document provides detailed step-by-step instructions for integrating OpenAI API into the ChatbotService. This includes HTTP client setup, API communication, response handling, and token management.

### 1.2 Scope
This implementation plan covers task P7.1.2:
- **P7.1.2**: Integrate OpenAI API
  - Install Guzzle HTTP client
  - Configure OpenAI API client
  - Implement API communication methods
  - Handle API responses and errors
  - Track token usage

### 1.3 Success Criteria
- Guzzle HTTP client installed
- OpenAI API client configured
- API communication working
- Responses properly parsed
- Token usage tracked
- Error handling implemented
- API rate limits respected

## 2. Prerequisites

### 2.1 Required Knowledge
- HTTP client usage (Guzzle)
- REST API integration
- OpenAI API documentation
- JSON parsing
- Error handling patterns

### 2.2 Dependencies
- Task P7.1.1 completed (ChatbotService structure)
- OpenAI API account and API key
- Internet connectivity for API calls
- Guzzle HTTP client package

### 2.3 Reference Documents
- AI Chatbot Architecture: `documentation/01-architecture/06-ai-chatbot-architecture.md`
- OpenAI API Documentation: https://platform.openai.com/docs/api-reference
- ChatbotService: `app/Services/ChatbotService.php`

## 3. Existing Implementation Review

### 3.1 Current State
- ChatbotService has placeholder `sendMessage()` method
- Configuration structure in place
- Message saving working
- Context management ready

### 3.2 What Needs to Be Done
- Install Guzzle HTTP client
- Create OpenAI API client wrapper
- Implement API call methods
- Integrate with ChatbotService
- Handle API responses
- Track token usage
- Implement error handling

## 4. Task P7.1.2: Integrate OpenAI API

### 4.1 Overview
Integrate OpenAI API by:
1. Installing Guzzle HTTP client
2. Creating OpenAI API client
3. Implementing API communication
4. Integrating with ChatbotService
5. Handling responses and errors

### 4.2 Step-by-Step Implementation

#### Step 1: Install Guzzle HTTP Client

**Command:**
```bash
composer require guzzlehttp/guzzle
```

**Verify installation:**
```bash
composer show guzzlehttp/guzzle
```

#### Step 2: Update Services Configuration

**File: `config/services.php`**

Add OpenAI configuration:

```php
<?php

return [
    // ... existing services ...

    'openai' => [
        'api_key' => env('OPENAI_API_KEY'),
        'base_uri' => env('OPENAI_BASE_URI', 'https://api.openai.com/v1/'),
        'model' => env('OPENAI_MODEL', 'gpt-4'),
        'max_tokens' => env('OPENAI_MAX_TOKENS', 500),
        'temperature' => env('OPENAI_TEMPERATURE', 0.7),
        'timeout' => env('OPENAI_TIMEOUT', 30),
    ],
];
```

#### Step 3: Create OpenAI Client Service

**File: `app/Services/OpenAIClient.php`**

Create new service for OpenAI API communication:

```php
<?php

namespace App\Services;

use GuzzleHttp\Client;
use GuzzleHttp\Exception\ClientException;
use GuzzleHttp\Exception\ServerException;
use GuzzleHttp\Exception\RequestException;
use Illuminate\Support\Facades\Log;

class OpenAIClient extends BaseService
{
    protected Client $client;
    protected string $apiKey;
    protected string $model;
    protected int $maxTokens;
    protected float $temperature;
    protected int $timeout;

    public function __construct()
    {
        $this->apiKey = config('services.openai.api_key');
        $this->model = config('services.openai.model', 'gpt-4');
        $this->maxTokens = config('services.openai.max_tokens', 500);
        $this->temperature = config('services.openai.temperature', 0.7);
        $this->timeout = config('services.openai.timeout', 30);

        if (empty($this->apiKey)) {
            throw new \RuntimeException('OpenAI API key is not configured');
        }

        $this->client = new Client([
            'base_uri' => config('services.openai.base_uri', 'https://api.openai.com/v1/'),
            'headers' => [
                'Authorization' => 'Bearer ' . $this->apiKey,
                'Content-Type' => 'application/json',
            ],
            'timeout' => $this->timeout,
        ]);
    }

    /**
     * Send chat completion request
     *
     * @param array $messages
     * @param array $options
     * @return array
     * @throws \Exception
     */
    public function chatCompletion(array $messages, array $options = []): array
    {
        try {
            $payload = [
                'model' => $options['model'] ?? $this->model,
                'messages' => $messages,
                'max_tokens' => $options['max_tokens'] ?? $this->maxTokens,
                'temperature' => $options['temperature'] ?? $this->temperature,
            ];

            Log::debug('OpenAI API request', [
                'model' => $payload['model'],
                'message_count' => count($messages),
                'max_tokens' => $payload['max_tokens'],
            ]);

            $response = $this->client->post('chat/completions', [
                'json' => $payload,
            ]);

            $data = json_decode($response->getBody()->getContents(), true);

            if (!isset($data['choices'][0]['message']['content'])) {
                throw new \RuntimeException('Invalid response from OpenAI API');
            }

            $result = [
                'content' => $data['choices'][0]['message']['content'],
                'tokens_used' => $data['usage']['total_tokens'] ?? null,
                'prompt_tokens' => $data['usage']['prompt_tokens'] ?? null,
                'completion_tokens' => $data['usage']['completion_tokens'] ?? null,
                'model' => $data['model'] ?? $this->model,
                'finish_reason' => $data['choices'][0]['finish_reason'] ?? null,
            ];

            Log::info('OpenAI API response', [
                'tokens_used' => $result['tokens_used'],
                'model' => $result['model'],
            ]);

            return $result;
        } catch (ClientException $e) {
            $this->handleClientError($e);
            throw $e;
        } catch (ServerException $e) {
            $this->handleServerError($e);
            throw $e;
        } catch (RequestException $e) {
            $this->handleRequestError($e);
            throw $e;
        } catch (\Exception $e) {
            Log::error('OpenAI API error', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
            throw $e;
        }
    }

    /**
     * Build messages array for API
     *
     * @param string $systemPrompt
     * @param array $conversationHistory
     * @param string $userMessage
     * @return array
     */
    public function buildMessagesArray(string $systemPrompt, array $conversationHistory, string $userMessage): array
    {
        $messages = [];

        // Add system message
        if (!empty($systemPrompt)) {
            $messages[] = [
                'role' => 'system',
                'content' => $systemPrompt,
            ];
        }

        // Add conversation history
        foreach ($conversationHistory as $message) {
            $messages[] = [
                'role' => $message['role'] ?? 'user',
                'content' => $message['content'] ?? '',
            ];
        }

        // Add current user message
        $messages[] = [
            'role' => 'user',
            'content' => $userMessage,
        ];

        return $messages;
    }

    /**
     * Handle client errors (4xx)
     *
     * @param ClientException $e
     * @return void
     */
    protected function handleClientError(ClientException $e): void
    {
        $statusCode = $e->getResponse()->getStatusCode();
        $body = $e->getResponse()->getBody()->getContents();
        $data = json_decode($body, true);

        $errorMessage = $data['error']['message'] ?? 'OpenAI API client error';

        Log::error('OpenAI API client error', [
            'status_code' => $statusCode,
            'error' => $errorMessage,
            'response' => $data,
        ]);

        // Handle specific error codes
        if ($statusCode === 401) {
            throw new \RuntimeException('Invalid OpenAI API key');
        } elseif ($statusCode === 429) {
            throw new \RuntimeException('OpenAI API rate limit exceeded');
        } elseif ($statusCode === 400) {
            throw new \InvalidArgumentException('Invalid request to OpenAI API: ' . $errorMessage);
        }
    }

    /**
     * Handle server errors (5xx)
     *
     * @param ServerException $e
     * @return void
     */
    protected function handleServerError(ServerException $e): void
    {
        $statusCode = $e->getResponse()->getStatusCode();

        Log::error('OpenAI API server error', [
            'status_code' => $statusCode,
            'error' => $e->getMessage(),
        ]);

        throw new \RuntimeException('OpenAI API is temporarily unavailable. Please try again later.');
    }

    /**
     * Handle request errors
     *
     * @param RequestException $e
     * @return void
     */
    protected function handleRequestError(RequestException $e): void
    {
        Log::error('OpenAI API request error', [
            'error' => $e->getMessage(),
        ]);

        if ($e->hasResponse()) {
            throw new \RuntimeException('Failed to communicate with OpenAI API');
        } else {
            throw new \RuntimeException('Network error: Unable to reach OpenAI API');
        }
    }

    /**
     * Check if API key is configured
     *
     * @return bool
     */
    public function isConfigured(): bool
    {
        return !empty($this->apiKey);
    }
}
```

#### Step 4: Update ChatbotService to Use OpenAI

**File: `app/Services/ChatbotService.php`**

Update the `sendMessage()` method:

```php
<?php

namespace App\Services;

use App\Models\ChatbotConversation;
use App\Models\ChatbotMessage;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Cache;

class ChatbotService extends BaseService
{
    protected OpenAIClient $openAIClient;
    protected int $maxContextMessages;
    protected int $conversationCacheTtl;

    public function __construct(OpenAIClient $openAIClient)
    {
        $this->openAIClient = $openAIClient;
        $this->maxContextMessages = config('chatbot.max_context_messages', 10);
        $this->conversationCacheTtl = config('chatbot.cache_ttl', 3600);
    }

    /**
     * Send a message and get response
     *
     * @param int $conversationId
     * @param string $message
     * @return array
     */
    public function sendMessage(int $conversationId, string $message): array
    {
        try {
            $conversation = ChatbotConversation::findOrFail($conversationId);
            
            // Validate message
            $this->validateMessage($message);

            // Save user message
            $userMessage = $this->saveMessage(
                $conversationId,
                'user',
                $message
            );

            // Get conversation context
            $conversationHistory = $this->getConversationContext($conversationId);

            // Get system prompt
            $systemPrompt = $this->getSystemPrompt($conversation);

            // Build messages array for OpenAI
            $messages = $this->openAIClient->buildMessagesArray(
                $systemPrompt,
                $conversationHistory,
                $message
            );

            // Call OpenAI API
            $aiResponse = $this->openAIClient->chatCompletion($messages);

            // Save AI response
            $aiMessage = $this->saveMessage(
                $conversationId,
                'assistant',
                $aiResponse['content'],
                $aiResponse['tokens_used']
            );

            // Update conversation context
            $this->updateConversationContext($conversation);

            Log::info('Chatbot message processed', [
                'conversation_id' => $conversationId,
                'user_message_id' => $userMessage->id,
                'ai_message_id' => $aiMessage->id,
                'tokens_used' => $aiResponse['tokens_used'],
            ]);

            return [
                'success' => true,
                'message' => $aiResponse['content'],
                'conversation_id' => $conversationId,
                'user_message_id' => $userMessage->id,
                'ai_message_id' => $aiMessage->id,
                'tokens_used' => $aiResponse['tokens_used'],
            ];
        } catch (\RuntimeException $e) {
            // Handle API errors gracefully
            Log::error('Chatbot API error', [
                'conversation_id' => $conversationId,
                'error' => $e->getMessage(),
            ]);

            // Save error message
            $errorMessage = "I'm sorry, I'm having trouble connecting right now. Please try again in a moment, or contact us directly for assistance.";
            
            $aiMessage = $this->saveMessage(
                $conversationId,
                'assistant',
                $errorMessage
            );

            return [
                'success' => false,
                'message' => $errorMessage,
                'conversation_id' => $conversationId,
                'error' => config('app.debug') ? $e->getMessage() : null,
            ];
        } catch (\Exception $e) {
            Log::error('Chatbot error', [
                'conversation_id' => $conversationId,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);

            return [
                'success' => false,
                'message' => 'Sorry, I encountered an error. Please try again later.',
                'error' => config('app.debug') ? $e->getMessage() : null,
            ];
        }
    }

    /**
     * Get system prompt for conversation
     *
     * @param ChatbotConversation $conversation
     * @return string
     */
    protected function getSystemPrompt(ChatbotConversation $conversation): string
    {
        $context = $conversation->context ?? $this->getDefaultContext();

        return "You are a helpful assistant for The Strengths Toolbox, a company that provides strengths-based development, team building, and sales training services.

Your role is to:
- Answer questions about services, programs, and offerings
- Help visitors understand the benefits of strengths-based development
- Guide visitors to relevant pages or resources
- Provide information about booking consultations
- Be friendly, professional, and concise

Key information about The Strengths Toolbox:
- Services: Strengths-based development, team building, sales training, facilitation workshops
- Founder: Eberhard Niklaus
- Contact: {$context['contact']['phone']}, {$context['contact']['email']}
- Main offering: Build Strong Teams. Unlock Strong Profits.

If you don't know the answer to something, politely direct the user to contact the company directly or visit the contact page.";
    }

    // ... rest of existing methods ...
}
```

#### Step 5: Update .env.example

**File: `.env.example`**

Ensure OpenAI configuration is present:

```env
# OpenAI Configuration
OPENAI_API_KEY=sk-your-api-key-here
OPENAI_MODEL=gpt-4
OPENAI_MAX_TOKENS=500
OPENAI_TEMPERATURE=0.7
OPENAI_TIMEOUT=30
OPENAI_BASE_URI=https://api.openai.com/v1/
```

## 5. Validation Steps

### 5.1 Code Validation

1. **Verify Guzzle is installed:**
   ```bash
   composer show guzzlehttp/guzzle
   ```

2. **Check OpenAIClient exists:**
   ```bash
   test -f app/Services/OpenAIClient.php && echo "OpenAIClient exists"
   ```

3. **Verify configuration:**
   ```bash
   php artisan tinker
   >>> config('services.openai.api_key')
   ```

### 5.2 Functional Testing

1. **Test OpenAIClient initialization:**
   ```php
   $client = app(\App\Services\OpenAIClient::class);
   assert($client->isConfigured() === true);
   ```

2. **Test message building:**
   ```php
   $messages = $client->buildMessagesArray(
       'You are a helpful assistant.',
       [['role' => 'user', 'content' => 'Hello']],
       'How are you?'
   );
   assert(count($messages) === 3);
   assert($messages[0]['role'] === 'system');
   ```

3. **Test API call (requires valid API key):**
   ```php
   $messages = [
       ['role' => 'user', 'content' => 'Hello, how are you?']
   ];
   $response = $client->chatCompletion($messages);
   assert(isset($response['content']));
   assert(isset($response['tokens_used']));
   ```

## 6. Error Handling

### 6.1 Common Errors

- **401 Unauthorized**: Invalid API key
- **429 Too Many Requests**: Rate limit exceeded
- **400 Bad Request**: Invalid request parameters
- **500 Server Error**: OpenAI service issue
- **Network Error**: Connection timeout or failure

### 6.2 Error Response Strategy

- Log all errors with context
- Return user-friendly error messages
- Save error messages to conversation
- Don't expose API keys or sensitive data
- Provide fallback responses

## 7. Next Steps

After completing this task:
- **P7.1.3**: Implement conversation context management
- **P7.1.4**: Add rate limiting
- **P7.1.5**: Implement comprehensive error handling

## 8. Notes

- Always validate API key before making requests
- Monitor token usage for cost tracking
- Implement retry logic for transient errors
- Cache system prompts for performance
- Log all API interactions for debugging

---

**Document Version:** 1.0  
**Last Updated:** 2025-01-27  
**Status:** Ready for Implementation
