# P7.3.3 API Connection Implementation Plan

## 1. Overview and Objectives

### 1.1 Purpose
This document provides detailed step-by-step instructions for connecting the frontend chatbot widget to the API endpoints. This includes API communication, error handling, and response processing.

### 1.2 Scope
This implementation plan covers task P7.3.3:
- **P7.3.3**: Connect to API endpoint
  - API request handling
  - Response processing
  - Error handling
  - Retry logic
  - Connection management

### 1.3 Success Criteria
- API connection working
- Requests properly formatted
- Responses handled correctly
- Error handling comprehensive
- Retry logic functional

## 2. Prerequisites

### 2.1 Required Knowledge
- Fetch API
- Async/await
- Error handling
- HTTP status codes

### 2.2 Dependencies
- Task P7.3.2 completed (Chat interface)
- Task P7.2.1 completed (API endpoints)
- API endpoints functional

### 2.3 Reference Documents
- Chatbot Widget: `resources/views/components/chatbot-widget.blade.php`
- API Endpoints: `routes/api.php`

## 3. Existing Implementation Review

### 3.1 Current State
- Basic API call in place
- Simple error handling
- No retry logic
- No connection management

### 3.2 What Needs to Be Done
- Enhance API connection
- Add retry logic
- Improve error handling
- Add connection status
- Implement request queuing

## 4. Task P7.3.3: Connect to API Endpoint

### 4.1 Overview
Enhance API connection by:
1. Creating API service
2. Adding retry logic
3. Implementing connection management
4. Adding request queuing
5. Improving error handling

### 4.2 Step-by-Step Implementation

#### Step 1: Create API Service Module

**File: `resources/js/chatbot-api.js`**

Create dedicated API service:

```javascript
class ChatbotAPI {
    constructor() {
        this.baseUrl = '/api/chatbot';
        this.csrfToken = document.querySelector('meta[name=csrf-token]')?.content;
        this.maxRetries = 3;
        this.retryDelay = 1000; // 1 second
    }

    /**
     * Send message to chatbot
     */
    async sendMessage(message, conversationId = null, sessionId = null) {
        const url = `${this.baseUrl}/message`;
        const body = {
            message: message,
            conversation_id: conversationId,
            session_id: sessionId,
        };

        return this.request(url, 'POST', body);
    }

    /**
     * Get conversation
     */
    async getConversation(conversationId) {
        const url = `${this.baseUrl}/conversation/${conversationId}`;
        return this.request(url, 'GET');
    }

    /**
     * Get conversation with pagination
     */
    async getConversationPaginated(conversationId, page = 1, perPage = 20) {
        const url = `${this.baseUrl}/conversation/${conversationId}/messages`;
        const params = new URLSearchParams({ page, per_page: perPage });
        return this.request(`${url}?${params}`, 'GET');
    }

    /**
     * Get conversation summary
     */
    async getConversationSummary(conversationId) {
        const url = `${this.baseUrl}/conversation/${conversationId}/summary`;
        return this.request(url, 'GET');
    }

    /**
     * Make API request with retry logic
     */
    async request(url, method = 'GET', body = null, retryCount = 0) {
        const options = {
            method: method,
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                'X-CSRF-TOKEN': this.csrfToken,
            },
        };

        if (body && method !== 'GET') {
            options.body = JSON.stringify(body);
        }

        try {
            const response = await fetch(url, options);

            // Handle non-OK responses
            if (!response.ok) {
                const errorData = await this.parseErrorResponse(response);
                
                // Retry on server errors (5xx)
                if (response.status >= 500 && retryCount < this.maxRetries) {
                    await this.delay(this.retryDelay * (retryCount + 1));
                    return this.request(url, method, body, retryCount + 1);
                }

                throw new APIError(errorData.message || 'Request failed', response.status, errorData);
            }

            return await response.json();
        } catch (error) {
            // Retry on network errors
            if (error instanceof TypeError && retryCount < this.maxRetries) {
                await this.delay(this.retryDelay * (retryCount + 1));
                return this.request(url, method, body, retryCount + 1);
            }

            throw error;
        }
    }

    /**
     * Parse error response
     */
    async parseErrorResponse(response) {
        try {
            return await response.json();
        } catch (e) {
            return {
                message: `HTTP ${response.status}: ${response.statusText}`,
                error_code: 'HTTP_ERROR',
            };
        }
    }

    /**
     * Delay helper
     */
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    /**
     * Check API health
     */
    async checkHealth() {
        try {
            const response = await fetch(`${this.baseUrl}/health`, {
                method: 'GET',
                headers: {
                    'Accept': 'application/json',
                },
            });
            return response.ok;
        } catch (error) {
            return false;
        }
    }
}

/**
 * API Error class
 */
class APIError extends Error {
    constructor(message, status, data = {}) {
        super(message);
        this.name = 'APIError';
        this.status = status;
        this.data = data;
    }
}

// Export for use in widget
window.ChatbotAPI = ChatbotAPI;
window.APIError = APIError;
```

#### Step 2: Update Widget to Use API Service

**File: `resources/views/components/chatbot-widget.blade.php`**

Update script to use API service:

```blade
{{-- Include API Service --}}
@push('scripts')
<script src="{{ asset('js/chatbot-api.js') }}"></script>
@endpush

<script>
function chatbotWidget() {
    return {
        // ... existing properties ...
        api: null,
        connectionStatus: 'connected', // connected, disconnected, error
        
        init() {
            // Initialize API service
            this.api = new ChatbotAPI();
            
            // ... existing init code ...
            
            // Check API health periodically
            this.checkConnectionHealth();
            setInterval(() => this.checkConnectionHealth(), 30000); // Every 30 seconds
        },
        
        async sendMessage() {
            if (!this.inputMessage.trim() || this.isLoading) return;
            
            const userMessage = this.inputMessage.trim();
            this.inputMessage = '';
            this.errorMessage = null;
            this.retryCount = 0;
            
            // Add user message to UI immediately
            const userMessageObj = {
                id: 'temp_' + Date.now(),
                role: 'user',
                content: userMessage,
                created_at: new Date().toISOString(),
            };
            this.messages.push(userMessageObj);
            
            this.scrollToBottom();
            this.isLoading = true;
            this.connectionStatus = 'connected';
            
            try {
                const response = await this.api.sendMessage(
                    userMessage,
                    this.conversationId,
                    this.sessionId
                );
                
                if (response.success) {
                    // Remove temp message and add real one
                    this.messages = this.messages.filter(m => m.id !== userMessageObj.id);
                    
                    // Add confirmed user message
                    this.messages.push({
                        id: response.user_message_id || Date.now(),
                        role: 'user',
                        content: userMessage,
                        created_at: new Date().toISOString(),
                    });
                    
                    // Add AI response
                    this.messages.push({
                        id: response.ai_message_id || Date.now() + 1,
                        role: 'assistant',
                        content: response.message,
                        created_at: new Date().toISOString(),
                    });
                    
                    // Update conversation ID
                    if (response.conversation_id) {
                        this.conversationId = response.conversation_id;
                        this.saveConversationId(response.conversation_id);
                    }
                    
                    // Handle rate limiting
                    if (response.rate_limit) {
                        this.handleRateLimit(response.rate_limit);
                    }
                } else {
                    this.handleErrorResponse(response, userMessageObj);
                }
            } catch (error) {
                console.error('Chatbot API error:', error);
                this.handleAPIError(error, userMessageObj);
            } finally {
                this.isLoading = false;
                this.scrollToBottom();
            }
        },
        
        handleAPIError(error, userMessageObj) {
            // Remove temp message
            this.messages = this.messages.filter(m => m.id !== userMessageObj.id);
            
            // Determine error message
            let errorMessage = 'Sorry, I encountered an error. Please try again.';
            
            if (error instanceof APIError) {
                if (error.status === 429) {
                    errorMessage = 'Rate limit exceeded. Please wait before sending another message.';
                    this.connectionStatus = 'error';
                } else if (error.status >= 500) {
                    errorMessage = 'The service is temporarily unavailable. Please try again in a moment.';
                    this.connectionStatus = 'error';
                } else if (error.status === 0 || error instanceof TypeError) {
                    errorMessage = 'Connection error. Please check your internet connection.';
                    this.connectionStatus = 'disconnected';
                } else {
                    errorMessage = error.data?.message || error.message;
                }
            } else if (error instanceof TypeError) {
                errorMessage = 'Connection error. Please check your internet connection.';
                this.connectionStatus = 'disconnected';
            }
            
            // Add error message
            this.messages.push({
                id: Date.now(),
                role: 'assistant',
                content: errorMessage,
                created_at: new Date().toISOString(),
                isError: true,
            });
            
            this.errorMessage = errorMessage;
            
            // Increment unread if widget is closed
            if (!this.isOpen) {
                this.unreadCount++;
            }
        },
        
        async loadConversationHistory() {
            if (!this.conversationId || this.conversationId === 'null') return;
            
            try {
                const data = await this.api.getConversation(this.conversationId);
                
                if (data.success && data.messages && data.messages.length > 0) {
                    this.messages = data.messages.map(msg => ({
                        id: msg.id,
                        role: msg.role,
                        content: msg.message,
                        created_at: msg.created_at,
                    }));
                    this.scrollToBottom();
                }
            } catch (error) {
                console.error('Failed to load conversation history:', error);
                // Don't show error to user, just start fresh
            }
        },
        
        async checkConnectionHealth() {
            const isHealthy = await this.api.checkHealth();
            this.connectionStatus = isHealthy ? 'connected' : 'disconnected';
        },
        
        // ... rest of existing methods ...
    };
}
</script>
```

#### Step 3: Add Connection Status Indicator

**File: `resources/views/components/chatbot-widget.blade.php`**

Add connection status to header:

```blade
{{-- Header --}}
<div class="bg-primary-600 text-white p-4 rounded-t-lg flex justify-between items-center">
    <div class="flex items-center gap-2">
        <div>
            <h3 class="font-semibold text-lg">Chat with us</h3>
            <p class="text-sm text-primary-100">We're here to help!</p>
        </div>
        <div class="flex items-center gap-1 ml-2">
            <span x-show="connectionStatus === 'connected'" 
                  class="w-2 h-2 bg-green-300 rounded-full animate-pulse"
                  title="Connected"></span>
            <span x-show="connectionStatus === 'disconnected'" 
                  class="w-2 h-2 bg-yellow-300 rounded-full"
                  title="Disconnected"></span>
            <span x-show="connectionStatus === 'error'" 
                  class="w-2 h-2 bg-red-300 rounded-full"
                  title="Error"></span>
        </div>
    </div>
    <button @click="toggleChat" class="text-white hover:text-primary-200 transition-colors p-1 rounded hover:bg-primary-700">
        {{-- ... close button ... --}}
    </button>
</div>
```

#### Step 4: Compile JavaScript (if using build process)

**File: `resources/js/app.js`**

If using Vite, import the API service:

```javascript
import './chatbot-api.js';
```

Or add to Vite config to include as separate file.

## 5. Validation Steps

### 5.1 Code Validation

1. **Check API service exists:**
   ```bash
   test -f resources/js/chatbot-api.js && echo "API service exists"
   ```

2. **Verify API service loaded:**
   - Check browser console for ChatbotAPI class
   - Verify no JavaScript errors

### 5.2 Functional Testing

1. **Test API connection:**
   - Open widget
   - Send message
   - Verify API call in network tab
   - Verify response received

2. **Test retry logic:**
   - Disconnect internet
   - Send message
   - Verify retry attempts
   - Reconnect and verify success

## 6. Next Steps

After completing this task:
- **P7.3.4**: Add loading states and animations

## 7. Notes

- API service handles retries automatically
- Connection status updates in real-time
- Errors are user-friendly
- Requests include CSRF token

---

**Document Version:** 1.0  
**Last Updated:** 2025-01-27  
**Status:** Ready for Implementation
