# P7.2.1 API Endpoints Implementation Plan

## 1. Overview and Objectives

### 1.1 Purpose
This document provides detailed step-by-step instructions for completing the chatbot API endpoints. This includes request validation, response formatting, and proper error handling.

### 1.2 Scope
This implementation plan covers task P7.2.1:
- **P7.2.1**: Build chatbot API endpoint
  - Complete sendMessage endpoint
  - Add request validation
  - Implement response formatting
  - Add proper error handling
  - Include rate limit headers

### 1.3 Success Criteria
- API endpoints fully functional
- Request validation working
- Responses properly formatted
- Error handling comprehensive
- Rate limit headers included
- API documentation complete

## 2. Prerequisites

### 2.1 Required Knowledge
- Laravel API development
- Request validation
- JSON responses
- HTTP status codes
- API best practices

### 2.2 Dependencies
- Task P7.1.1 completed (ChatbotService)
- Task P7.1.2 completed (OpenAI integration)
- Task P7.1.4 completed (Rate limiting)
- Task P7.1.5 completed (Error handling)
- API routes defined

### 2.3 Reference Documents
- AI Chatbot Architecture: `documentation/01-architecture/06-ai-chatbot-architecture.md`
- ChatbotController: `app/Http/Controllers/Api/ChatbotController.php`
- API Routes: `routes/api.php`

## 3. Existing Implementation Review

### 3.1 Current State
- Basic ChatbotController exists
- sendMessage() method partially implemented
- getConversation() method exists
- API routes defined
- Basic validation in place

### 3.2 What Needs to Be Done
- Complete sendMessage endpoint
- Enhance request validation
- Improve response formatting
- Add rate limit information
- Add request/response logging
- Improve error responses

## 4. Task P7.2.1: Build Chatbot API Endpoint

### 4.1 Overview
Complete the API endpoints by:
1. Enhancing request validation
2. Completing sendMessage implementation
3. Improving response formatting
4. Adding rate limit headers
5. Implementing proper error handling

### 4.2 Step-by-Step Implementation

#### Step 1: Complete ChatbotController

**File: `app/Http/Controllers/Api/ChatbotController.php`**

Complete implementation:

```php
<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Services\ChatbotService;
use App\Services\ChatbotRateLimitService;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Validator;

class ChatbotController extends Controller
{
    protected ChatbotService $chatbotService;
    protected ChatbotRateLimitService $rateLimitService;

    public function __construct(
        ChatbotService $chatbotService,
        ChatbotRateLimitService $rateLimitService
    ) {
        $this->chatbotService = $chatbotService;
        $this->rateLimitService = $rateLimitService;
    }

    /**
     * Send a message to the chatbot
     *
     * @param Request $request
     * @return JsonResponse
     */
    public function sendMessage(Request $request): JsonResponse
    {
        // Validate request
        $validator = Validator::make($request->all(), [
            'message' => 'required|string|max:1000|min:1',
            'conversation_id' => 'nullable|integer|exists:chatbot_conversations,id',
            'session_id' => 'nullable|string|max:255',
        ]);

        if ($validator->fails()) {
            return response()->json([
                'success' => false,
                'message' => 'Invalid request data.',
                'errors' => $validator->errors(),
            ], 422);
        }

        try {
            $conversationId = $request->input('conversation_id');
            $sessionId = $request->input('session_id') ?? session()->getId();
            $userId = auth()->check() ? auth()->id() : null;
            $ipAddress = $request->ip();
            $message = $request->input('message');

            // Get or create conversation
            if (!$conversationId) {
                $conversation = $this->chatbotService->createConversation($sessionId, $userId);
                $conversationId = $conversation->id;
            } else {
                $conversation = $this->chatbotService->getOrCreateConversation(
                    $conversationId,
                    $sessionId,
                    $userId
                );
                $conversationId = $conversation->id;
            }

            // Get rate limit status
            $rateLimitStatus = $this->rateLimitService->getRateLimitStatus($sessionId, 'session');

            // Send message and get response
            $response = $this->chatbotService->sendMessage(
                $conversationId,
                $message,
                $sessionId,
                $userId,
                $ipAddress
            );

            // Prepare response with rate limit info
            $jsonResponse = response()->json([
                'success' => $response['success'],
                'message' => $response['message'] ?? null,
                'conversation_id' => $conversationId,
                'user_message_id' => $response['user_message_id'] ?? null,
                'ai_message_id' => $response['ai_message_id'] ?? null,
                'tokens_used' => $response['tokens_used'] ?? null,
                'error' => $response['error'] ?? null,
                'error_code' => $response['error_code'] ?? null,
                'rate_limit' => $response['rate_limit'] ?? [
                    'remaining' => $rateLimitStatus['remaining'],
                    'reset_at' => \Carbon\Carbon::createFromTimestamp($rateLimitStatus['reset_at'])->toIso8601String(),
                ],
            ]);

            // Add rate limit headers
            if (isset($rateLimitStatus['limit'])) {
                $jsonResponse->withHeaders([
                    'X-RateLimit-Limit' => $rateLimitStatus['limit'],
                    'X-RateLimit-Remaining' => $rateLimitStatus['remaining'],
                    'X-RateLimit-Reset' => $rateLimitStatus['reset_at'],
                ]);
            }

            // Log successful request
            Log::info('Chatbot API request', [
                'conversation_id' => $conversationId,
                'session_id' => $sessionId,
                'user_id' => $userId,
                'message_length' => strlen($message),
                'success' => $response['success'],
            ]);

            return $jsonResponse;
        } catch (\Exception $e) {
            Log::error('Chatbot API error', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
                'request' => $request->all(),
            ]);

            return response()->json([
                'success' => false,
                'message' => 'An error occurred processing your request. Please try again.',
                'error_code' => 'CHATBOT_API_ERROR',
            ], 500);
        }
    }

    /**
     * Get conversation history
     *
     * @param Request $request
     * @param int $conversationId
     * @return JsonResponse
     */
    public function getConversation(Request $request, int $conversationId): JsonResponse
    {
        try {
            $conversation = $this->chatbotService->getConversation($conversationId);

            if (!$conversation) {
                return response()->json([
                    'success' => false,
                    'message' => 'Conversation not found.',
                    'error_code' => 'CONVERSATION_NOT_FOUND',
                ], 404);
            }

            // Check if user has access (optional - implement based on requirements)
            $userId = auth()->id();
            if ($userId && $conversation->user_id && $conversation->user_id !== $userId) {
                return response()->json([
                    'success' => false,
                    'message' => 'Unauthorized access to conversation.',
                    'error_code' => 'UNAUTHORIZED',
                ], 403);
            }

            // Format messages
            $messages = $conversation->messages->map(function ($message) {
                return [
                    'id' => $message->id,
                    'role' => $message->role,
                    'message' => $message->message,
                    'tokens_used' => $message->tokens_used,
                    'created_at' => $message->created_at->toIso8601String(),
                ];
            });

            return response()->json([
                'success' => true,
                'conversation' => [
                    'id' => $conversation->id,
                    'session_id' => $conversation->session_id,
                    'user_id' => $conversation->user_id,
                    'created_at' => $conversation->created_at->toIso8601String(),
                    'updated_at' => $conversation->updated_at->toIso8601String(),
                ],
                'messages' => $messages,
                'message_count' => $messages->count(),
            ]);
        } catch (\Exception $e) {
            Log::error('Chatbot conversation retrieval error', [
                'conversation_id' => $conversationId,
                'error' => $e->getMessage(),
            ]);

            return response()->json([
                'success' => false,
                'message' => 'An error occurred retrieving the conversation.',
                'error_code' => 'CONVERSATION_RETRIEVAL_ERROR',
            ], 500);
        }
    }

    /**
     * Get conversation statistics
     *
     * @param Request $request
     * @param int $conversationId
     * @return JsonResponse
     */
    public function getConversationStats(Request $request, int $conversationId): JsonResponse
    {
        try {
            $stats = $this->chatbotService->getConversationStats($conversationId);

            return response()->json([
                'success' => true,
                'stats' => $stats,
            ]);
        } catch (\Exception $e) {
            Log::error('Chatbot stats retrieval error', [
                'conversation_id' => $conversationId,
                'error' => $e->getMessage(),
            ]);

            return response()->json([
                'success' => false,
                'message' => 'An error occurred retrieving conversation statistics.',
                'error_code' => 'STATS_RETRIEVAL_ERROR',
            ], 500);
        }
    }
}
```

#### Step 2: Update API Routes

**File: `routes/api.php`**

Complete route definitions:

```php
<?php

use App\Http\Controllers\Api\ChatbotController;
use Illuminate\Support\Facades\Route;

Route::middleware('auth:sanctum')->get('/user', function (Request $request) {
    return $request->user();
});

// Chatbot API routes
Route::prefix('chatbot')->name('api.chatbot.')->group(function () {
    // Send message endpoint
    Route::post('/message', [ChatbotController::class, 'sendMessage'])
        ->middleware(['throttle:10,1', 'chatbot.ratelimit'])
        ->name('message');
    
    // Get conversation history
    Route::get('/conversation/{conversationId}', [ChatbotController::class, 'getConversation'])
        ->middleware(['throttle:20,1'])
        ->name('conversation');
    
    // Get conversation statistics
    Route::get('/conversation/{conversationId}/stats', [ChatbotController::class, 'getConversationStats'])
        ->middleware(['throttle:20,1'])
        ->name('conversation.stats');
});
```

#### Step 3: Create Request Validation Class (Optional)

**File: `app/Http/Requests/ChatbotMessageRequest.php`**

For better organization:

```php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class ChatbotMessageRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true; // Public API endpoint
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array<string, \Illuminate\Contracts\Validation\ValidationRule|array<mixed>|string>
     */
    public function rules(): array
    {
        return [
            'message' => 'required|string|max:1000|min:1',
            'conversation_id' => 'nullable|integer|exists:chatbot_conversations,id',
            'session_id' => 'nullable|string|max:255',
        ];
    }

    /**
     * Get custom messages for validator errors.
     *
     * @return array
     */
    public function messages(): array
    {
        return [
            'message.required' => 'A message is required.',
            'message.max' => 'Message cannot exceed 1000 characters.',
            'message.min' => 'Message cannot be empty.',
            'conversation_id.exists' => 'The specified conversation does not exist.',
        ];
    }
}
```

#### Step 4: Create API Resource (Optional)

**File: `app/Http/Resources/ChatbotMessageResource.php`**

For consistent response formatting:

```php
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class ChatbotMessageResource extends JsonResource
{
    /**
     * Transform the resource into an array.
     *
     * @return array<string, mixed>
     */
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
            'role' => $this->role,
            'message' => $this->message,
            'tokens_used' => $this->tokens_used,
            'created_at' => $this->created_at->toIso8601String(),
        ];
    }
}
```

**File: `app/Http/Resources/ChatbotConversationResource.php`**

```php
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class ChatbotConversationResource extends JsonResource
{
    /**
     * Transform the resource into an array.
     *
     * @return array<string, mixed>
     */
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
            'session_id' => $this->session_id,
            'user_id' => $this->user_id,
            'created_at' => $this->created_at->toIso8601String(),
            'updated_at' => $this->updated_at->toIso8601String(),
            'messages' => ChatbotMessageResource::collection($this->whenLoaded('messages')),
            'message_count' => $this->whenLoaded('messages', fn() => $this->messages->count()),
        ];
    }
}
```

## 5. Validation Steps

### 5.1 Code Validation

1. **Check controller is complete:**
   ```bash
   grep -n "sendMessage\|getConversation" app/Http/Controllers/Api/ChatbotController.php
   ```

2. **Verify routes are registered:**
   ```bash
   php artisan route:list | grep chatbot
   ```

### 5.2 Functional Testing

1. **Test sendMessage endpoint:**
   ```bash
   curl -X POST http://localhost:8000/api/chatbot/message \
     -H "Content-Type: application/json" \
     -H "X-CSRF-TOKEN: your-token" \
     -d '{"message": "Hello"}'
   ```

2. **Test getConversation endpoint:**
   ```bash
   curl http://localhost:8000/api/chatbot/conversation/1
   ```

## 6. API Documentation

### 6.1 Endpoint: POST /api/chatbot/message

**Request:**
```json
{
  "message": "Hello, how can you help me?",
  "conversation_id": 1,
  "session_id": "session_123"
}
```

**Response (Success):**
```json
{
  "success": true,
  "message": "Hello! I'm here to help...",
  "conversation_id": 1,
  "user_message_id": 10,
  "ai_message_id": 11,
  "tokens_used": 150,
  "rate_limit": {
    "remaining": 9,
    "reset_at": "2025-01-27T12:01:00Z"
  }
}
```

**Response (Error):**
```json
{
  "success": false,
  "message": "Rate limit exceeded. Please try again later.",
  "error_code": "CHATBOT_RATE_LIMIT",
  "rate_limit": {
    "remaining": 0,
    "reset_at": "2025-01-27T12:01:00Z"
  }
}
```

### 6.2 Endpoint: GET /api/chatbot/conversation/{conversationId}

**Response:**
```json
{
  "success": true,
  "conversation": {
    "id": 1,
    "session_id": "session_123",
    "user_id": null,
    "created_at": "2025-01-27T10:00:00Z",
    "updated_at": "2025-01-27T12:00:00Z"
  },
  "messages": [
    {
      "id": 1,
      "role": "user",
      "message": "Hello",
      "tokens_used": null,
      "created_at": "2025-01-27T10:00:00Z"
    }
  ],
  "message_count": 1
}
```

## 7. Next Steps

After completing this task:
- **P7.2.2**: Implement conversation storage
- **P7.2.3**: Add conversation retrieval

## 8. Notes

- All endpoints include rate limit information
- Error responses are consistent
- Request validation is comprehensive
- Responses include all necessary metadata

---

**Document Version:** 1.0  
**Last Updated:** 2025-01-27  
**Status:** Ready for Implementation
