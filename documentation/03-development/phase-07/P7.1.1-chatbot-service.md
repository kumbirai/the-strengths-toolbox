# P7.1.1 Chatbot Service Implementation Plan

## 1. Overview and Objectives

### 1.1 Purpose
This document provides detailed step-by-step instructions for completing the ChatbotService implementation. The service will handle conversation management, message processing, and serve as the foundation for OpenAI API integration.

### 1.2 Scope
This implementation plan covers task P7.1.1:
- **P7.1.1**: Implement ChatbotService
  - Complete service structure
  - Conversation lifecycle management
  - Message handling
  - Context preparation
  - Integration points for OpenAI API

### 1.3 Success Criteria
- ChatbotService extends BaseService
- All conversation management methods implemented
- Message creation and retrieval working
- Context building methods ready
- Service follows DDD and Clean Architecture principles
- Proper error handling and logging
- Service is testable and maintainable

## 2. Prerequisites

### 2.1 Required Knowledge
- Laravel service layer patterns
- Domain-Driven Design principles
- Clean Architecture concepts
- Eloquent ORM relationships
- Dependency injection

### 2.2 Dependencies
- Task P1.2.3 completed (Database migrations for chatbot tables)
- Task P2.1.6 completed (BaseService created)
- `ChatbotConversation` model exists
- `ChatbotMessage` model exists
- Database tables created and migrated

### 2.3 Reference Documents
- AI Chatbot Architecture: `documentation/01-architecture/06-ai-chatbot-architecture.md`
- Database Architecture: `documentation/01-architecture/03-database-architecture.md`
- BaseService: `app/Services/BaseService.php`
- Existing ChatbotService: `app/Services/ChatbotService.php`

## 3. Existing Implementation Review

### 3.1 Current State
The following components are already implemented:
- `ChatbotConversation` model with relationships
- `ChatbotMessage` model with relationships
- Basic `ChatbotService` with placeholder methods:
  - `createConversation()` - Creates new conversation
  - `getOrCreateConversation()` - Gets or creates conversation
  - `sendMessage()` - Placeholder with TODO for OpenAI
  - `getConversation()` - Retrieves conversation with messages
- Database migrations for `chatbot_conversations` and `chatbot_messages` tables

### 3.2 What Needs to Be Done
- Extend BaseService for consistent error handling
- Add conversation context management methods
- Implement message history retrieval with pagination
- Add conversation statistics methods
- Implement conversation cleanup/archival
- Add validation methods
- Prepare service for OpenAI integration
- Add comprehensive logging

## 4. Task P7.1.1: Implement ChatbotService

### 4.1 Overview
Complete the ChatbotService implementation by:
1. Extending BaseService
2. Adding conversation management methods
3. Implementing message handling
4. Adding context management
5. Preparing for OpenAI integration

### 4.2 Step-by-Step Implementation

#### Step 1: Update ChatbotService to Extend BaseService

**File: `app/Services/ChatbotService.php`**

**Current state:** Basic service with placeholder methods

**Update required:**
```php
<?php

namespace App\Services;

use App\Models\ChatbotConversation;
use App\Models\ChatbotMessage;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Cache;

class ChatbotService extends BaseService
{
    protected int $maxContextMessages;
    protected int $conversationCacheTtl;

    public function __construct()
    {
        $this->maxContextMessages = config('chatbot.max_context_messages', 10);
        $this->conversationCacheTtl = config('chatbot.cache_ttl', 3600);
    }

    /**
     * Create a new conversation
     *
     * @param string $sessionId
     * @param int|null $userId
     * @return ChatbotConversation
     */
    public function createConversation(string $sessionId, ?int $userId = null): ChatbotConversation
    {
        try {
            $this->validateSessionId($sessionId);

            $conversation = ChatbotConversation::create([
                'session_id' => $sessionId,
                'user_id' => $userId,
                'context' => $this->getDefaultContext(),
            ]);

            Log::info('Chatbot conversation created', [
                'conversation_id' => $conversation->id,
                'session_id' => $sessionId,
                'user_id' => $userId,
            ]);

            return $conversation;
        } catch (\Exception $e) {
            $this->handleError($e, 'Failed to create chatbot conversation');
            throw $e;
        }
    }

    /**
     * Get or create conversation
     *
     * @param int|null $conversationId
     * @param string $sessionId
     * @param int|null $userId
     * @return ChatbotConversation
     */
    public function getOrCreateConversation(?int $conversationId, string $sessionId, ?int $userId = null): ChatbotConversation
    {
        try {
            // If conversation ID provided, try to find it
            if ($conversationId) {
                $conversation = ChatbotConversation::find($conversationId);
                if ($conversation) {
                    // Update user_id if provided and different
                    if ($userId && $conversation->user_id !== $userId) {
                        $conversation->update(['user_id' => $userId]);
                    }
                    return $conversation;
                }
            }

            // Try to find by session_id
            $conversation = ChatbotConversation::where('session_id', $sessionId)->first();

            if ($conversation) {
                // Update user_id if provided and different
                if ($userId && $conversation->user_id !== $userId) {
                    $conversation->update(['user_id' => $userId]);
                }
                return $conversation;
            }

            // Create new conversation
            return $this->createConversation($sessionId, $userId);
        } catch (\Exception $e) {
            $this->handleError($e, 'Failed to get or create chatbot conversation');
            throw $e;
        }
    }

    /**
     * Send a message and get response
     *
     * @param int $conversationId
     * @param string $message
     * @return array
     */
    public function sendMessage(int $conversationId, string $message): array
    {
        try {
            $conversation = ChatbotConversation::findOrFail($conversationId);
            
            // Validate message
            $this->validateMessage($message);

            // Save user message
            $userMessage = $this->saveMessage(
                $conversationId,
                'user',
                $message
            );

            // TODO: Integrate with OpenAI API (P7.1.2)
            // For now, return a placeholder response
            $response = "Thank you for your message. The chatbot service is being configured. Please contact us directly for assistance.";

            // Save AI response
            $aiMessage = $this->saveMessage(
                $conversationId,
                'assistant',
                $response
            );

            // Update conversation context
            $this->updateConversationContext($conversation);

            Log::info('Chatbot message processed', [
                'conversation_id' => $conversationId,
                'user_message_id' => $userMessage->id,
                'ai_message_id' => $aiMessage->id,
            ]);

            return [
                'success' => true,
                'message' => $response,
                'conversation_id' => $conversationId,
                'user_message_id' => $userMessage->id,
                'ai_message_id' => $aiMessage->id,
            ];
        } catch (\Exception $e) {
            Log::error('Chatbot error', [
                'conversation_id' => $conversationId,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);

            return [
                'success' => false,
                'message' => 'Sorry, I encountered an error. Please try again later.',
                'error' => config('app.debug') ? $e->getMessage() : null,
            ];
        }
    }

    /**
     * Get conversation with messages
     *
     * @param int $conversationId
     * @return ChatbotConversation|null
     */
    public function getConversation(int $conversationId): ?ChatbotConversation
    {
        return Cache::remember(
            "chatbot.conversation.{$conversationId}",
            $this->conversationCacheTtl,
            function () use ($conversationId) {
                return ChatbotConversation::with('messages')
                    ->find($conversationId);
            }
        );
    }

    /**
     * Get conversation history (last N messages)
     *
     * @param int $conversationId
     * @param int $limit
     * @return \Illuminate\Database\Eloquent\Collection
     */
    public function getConversationHistory(int $conversationId, int $limit = null): \Illuminate\Database\Eloquent\Collection
    {
        $limit = $limit ?? $this->maxContextMessages;

        return ChatbotMessage::where('conversation_id', $conversationId)
            ->orderBy('created_at', 'asc')
            ->limit($limit)
            ->get();
    }

    /**
     * Get conversation context for OpenAI
     *
     * @param int $conversationId
     * @return array
     */
    public function getConversationContext(int $conversationId): array
    {
        $messages = $this->getConversationHistory($conversationId, $this->maxContextMessages);

        return $messages->map(function ($message) {
            return [
                'role' => $message->role,
                'content' => $message->message,
            ];
        })->toArray();
    }

    /**
     * Save a message
     *
     * @param int $conversationId
     * @param string $role
     * @param string $message
     * @param int|null $tokensUsed
     * @return ChatbotMessage
     */
    public function saveMessage(int $conversationId, string $role, string $message, ?int $tokensUsed = null): ChatbotMessage
    {
        try {
            $this->validateRole($role);
            $this->validateMessage($message);

            $chatbotMessage = ChatbotMessage::create([
                'conversation_id' => $conversationId,
                'role' => $role,
                'message' => $message,
                'tokens_used' => $tokensUsed,
            ]);

            // Clear conversation cache
            Cache::forget("chatbot.conversation.{$conversationId}");

            return $chatbotMessage;
        } catch (\Exception $e) {
            $this->handleError($e, 'Failed to save chatbot message');
            throw $e;
        }
    }

    /**
     * Update conversation context
     *
     * @param ChatbotConversation $conversation
     * @return void
     */
    public function updateConversationContext(ChatbotConversation $conversation): void
    {
        try {
            $messageCount = $conversation->messages()->count();
            $lastMessage = $conversation->messages()->latest()->first();

            $context = array_merge($conversation->context ?? [], [
                'message_count' => $messageCount,
                'last_message_at' => $lastMessage?->created_at?->toIso8601String(),
                'updated_at' => now()->toIso8601String(),
            ]);

            $conversation->update(['context' => $context]);

            // Clear cache
            Cache::forget("chatbot.conversation.{$conversation->id}");
        } catch (\Exception $e) {
            Log::warning('Failed to update conversation context', [
                'conversation_id' => $conversation->id,
                'error' => $e->getMessage(),
            ]);
        }
    }

    /**
     * Get conversation statistics
     *
     * @param int $conversationId
     * @return array
     */
    public function getConversationStats(int $conversationId): array
    {
        $conversation = ChatbotConversation::findOrFail($conversationId);

        $messages = $conversation->messages;

        return [
            'total_messages' => $messages->count(),
            'user_messages' => $messages->where('role', 'user')->count(),
            'assistant_messages' => $messages->where('role', 'assistant')->count(),
            'total_tokens' => $messages->sum('tokens_used') ?? 0,
            'created_at' => $conversation->created_at->toIso8601String(),
            'last_message_at' => $messages->last()?->created_at?->toIso8601String(),
        ];
    }

    /**
     * Get default context
     *
     * @return array
     */
    protected function getDefaultContext(): array
    {
        return [
            'company' => 'The Strengths Toolbox',
            'services' => [
                'Strengths-based development',
                'Team building',
                'Sales training',
                'Facilitation workshops',
            ],
            'contact' => [
                'phone' => '+27 83 294 8033',
                'email' => 'welcome@eberhardniklaus.co.za',
            ],
            'created_at' => now()->toIso8601String(),
        ];
    }

    /**
     * Validate session ID
     *
     * @param string $sessionId
     * @return void
     * @throws \InvalidArgumentException
     */
    protected function validateSessionId(string $sessionId): void
    {
        if (empty($sessionId)) {
            throw new \InvalidArgumentException('Session ID cannot be empty');
        }

        if (strlen($sessionId) > 255) {
            throw new \InvalidArgumentException('Session ID cannot exceed 255 characters');
        }
    }

    /**
     * Validate message
     *
     * @param string $message
     * @return void
     * @throws \InvalidArgumentException
     */
    protected function validateMessage(string $message): void
    {
        if (empty(trim($message))) {
            throw new \InvalidArgumentException('Message cannot be empty');
        }

        $maxLength = config('chatbot.max_message_length', 1000);
        if (strlen($message) > $maxLength) {
            throw new \InvalidArgumentException("Message cannot exceed {$maxLength} characters");
        }
    }

    /**
     * Validate role
     *
     * @param string $role
     * @return void
     * @throws \InvalidArgumentException
     */
    protected function validateRole(string $role): void
    {
        $validRoles = ['user', 'assistant', 'system'];
        
        if (!in_array($role, $validRoles)) {
            throw new \InvalidArgumentException("Invalid role. Must be one of: " . implode(', ', $validRoles));
        }
    }
}
```

#### Step 2: Add Configuration

**File: `config/chatbot.php`**

Create new configuration file:

```php
<?php

return [
    /*
    |--------------------------------------------------------------------------
    | Chatbot Configuration
    |--------------------------------------------------------------------------
    |
    | Configuration for the AI chatbot service
    |
    */

    'max_context_messages' => env('CHATBOT_MAX_CONTEXT_MESSAGES', 10),
    'max_message_length' => env('CHATBOT_MAX_MESSAGE_LENGTH', 1000),
    'cache_ttl' => env('CHATBOT_CACHE_TTL', 3600), // 1 hour

    /*
    |--------------------------------------------------------------------------
    | OpenAI Configuration
    |--------------------------------------------------------------------------
    */

    'openai' => [
        'model' => env('OPENAI_MODEL', 'gpt-4'),
        'max_tokens' => env('OPENAI_MAX_TOKENS', 500),
        'temperature' => env('OPENAI_TEMPERATURE', 0.7),
        'timeout' => env('OPENAI_TIMEOUT', 30),
    ],
];
```

#### Step 3: Update .env.example

**File: `.env.example`**

Add chatbot configuration:

```env
# Chatbot Configuration
CHATBOT_MAX_CONTEXT_MESSAGES=10
CHATBOT_MAX_MESSAGE_LENGTH=1000
CHATBOT_CACHE_TTL=3600

# OpenAI Configuration
OPENAI_API_KEY=
OPENAI_MODEL=gpt-4
OPENAI_MAX_TOKENS=500
OPENAI_TEMPERATURE=0.7
OPENAI_TIMEOUT=30
```

## 5. Validation Steps

### 5.1 Code Validation

1. **Check service extends BaseService:**
   ```bash
   grep -n "extends BaseService" app/Services/ChatbotService.php
   ```

2. **Verify all methods are implemented:**
   - `createConversation()`
   - `getOrCreateConversation()`
   - `sendMessage()`
   - `getConversation()`
   - `getConversationHistory()`
   - `getConversationContext()`
   - `saveMessage()`
   - `updateConversationContext()`
   - `getConversationStats()`

3. **Check configuration file exists:**
   ```bash
   test -f config/chatbot.php && echo "Config file exists"
   ```

### 5.2 Functional Testing

1. **Test conversation creation:**
   ```php
   $service = app(\App\Services\ChatbotService::class);
   $conversation = $service->createConversation('test_session_123');
   assert($conversation instanceof \App\Models\ChatbotConversation);
   ```

2. **Test message saving:**
   ```php
   $message = $service->saveMessage($conversation->id, 'user', 'Hello');
   assert($message instanceof \App\Models\ChatbotMessage);
   ```

3. **Test conversation retrieval:**
   ```php
   $retrieved = $service->getConversation($conversation->id);
   assert($retrieved !== null);
   assert($retrieved->messages->count() > 0);
   ```

## 6. Next Steps

After completing this task:
- **P7.1.2**: Integrate OpenAI API
- **P7.1.3**: Implement conversation context management
- **P7.1.4**: Add rate limiting
- **P7.1.5**: Implement error handling

## 7. Notes

- The service uses caching to improve performance
- All methods include proper error handling and logging
- Validation methods ensure data integrity
- The service is ready for OpenAI integration in the next task
- Context management prepares messages for AI processing

---

**Document Version:** 1.0  
**Last Updated:** 2025-01-27  
**Status:** Ready for Implementation
