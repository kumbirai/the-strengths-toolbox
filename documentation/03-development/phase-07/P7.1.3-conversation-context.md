# P7.1.3 Conversation Context Implementation Plan

## 1. Overview and Objectives

### 1.1 Purpose
This document provides detailed step-by-step instructions for implementing conversation context management in the ChatbotService. Context management ensures the AI has relevant conversation history and company information to provide accurate responses.

### 1.2 Scope
This implementation plan covers task P7.1.3:
- **P7.1.3**: Implement conversation context
  - Context building from conversation history
  - System prompt management
  - Context optimization for token limits
  - Dynamic context updates
  - Context caching

### 1.3 Success Criteria
- Context properly built from conversation history
- System prompts configurable
- Token limits respected
- Context optimized for API calls
- Dynamic context updates working
- Context caching implemented

## 2. Prerequisites

### 2.1 Required Knowledge
- OpenAI API message format
- Token counting basics
- Context window management
- Prompt engineering

### 2.2 Dependencies
- Task P7.1.1 completed (ChatbotService structure)
- Task P7.1.2 completed (OpenAI integration)
- Database models working
- Message history available

### 2.3 Reference Documents
- AI Chatbot Architecture: `documentation/01-architecture/06-ai-chatbot-architecture.md`
- ChatbotService: `app/Services/ChatbotService.php`
- OpenAIClient: `app/Services/OpenAIClient.php`

## 3. Existing Implementation Review

### 3.1 Current State
- Basic context retrieval implemented
- Default context structure exists
- Conversation history retrieval working
- System prompt hardcoded

### 3.2 What Needs to Be Done
- Optimize context for token limits
- Implement smart context truncation
- Add configurable system prompts
- Implement context summarization
- Add context validation
- Improve context caching

## 4. Task P7.1.3: Implement Conversation Context

### 4.1 Overview
Enhance conversation context management by:
1. Optimizing context for token limits
2. Implementing smart truncation
3. Making system prompts configurable
4. Adding context validation
5. Improving caching strategy

### 4.2 Step-by-Step Implementation

#### Step 1: Add Context Configuration

**File: `config/chatbot.php`**

Add context-related configuration:

```php
<?php

return [
    // ... existing config ...

    /*
    |--------------------------------------------------------------------------
    | Context Configuration
    |--------------------------------------------------------------------------
    */

    'context' => [
        'max_messages' => env('CHATBOT_MAX_CONTEXT_MESSAGES', 10),
        'max_tokens' => env('CHATBOT_MAX_CONTEXT_TOKENS', 2000),
        'include_system_prompt' => env('CHATBOT_INCLUDE_SYSTEM_PROMPT', true),
        'truncate_old_messages' => env('CHATBOT_TRUNCATE_OLD_MESSAGES', true),
    ],

    /*
    |--------------------------------------------------------------------------
    | System Prompt Configuration
    |--------------------------------------------------------------------------
    */

    'system_prompt' => [
        'enabled' => env('CHATBOT_SYSTEM_PROMPT_ENABLED', true),
        'template' => env('CHATBOT_SYSTEM_PROMPT_TEMPLATE', 'default'),
        'custom' => env('CHATBOT_SYSTEM_PROMPT_CUSTOM', null),
    ],
];
```

#### Step 2: Create Context Service

**File: `app/Services/ChatbotContextService.php`**

Create dedicated service for context management:

```php
<?php

namespace App\Services;

use App\Models\ChatbotConversation;
use App\Models\ChatbotMessage;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;

class ChatbotContextService extends BaseService
{
    protected int $maxMessages;
    protected int $maxTokens;
    protected bool $truncateOldMessages;

    public function __construct()
    {
        $this->maxMessages = config('chatbot.context.max_messages', 10);
        $this->maxTokens = config('chatbot.context.max_tokens', 2000);
        $this->truncateOldMessages = config('chatbot.context.truncate_old_messages', true);
    }

    /**
     * Build conversation context for OpenAI
     *
     * @param ChatbotConversation $conversation
     * @param string $newUserMessage
     * @return array
     */
    public function buildContext(ChatbotConversation $conversation, string $newUserMessage = ''): array
    {
        $cacheKey = "chatbot.context.{$conversation->id}";

        return Cache::remember($cacheKey, 300, function () use ($conversation, $newUserMessage) {
            // Get conversation history
            $messages = $this->getConversationHistory($conversation);

            // Build messages array
            $contextMessages = $this->buildMessagesArray($messages, $newUserMessage);

            // Optimize for token limits
            $optimizedMessages = $this->optimizeForTokens($contextMessages);

            return $optimizedMessages;
        });
    }

    /**
     * Get conversation history
     *
     * @param ChatbotConversation $conversation
     * @return \Illuminate\Database\Eloquent\Collection
     */
    protected function getConversationHistory(ChatbotConversation $conversation): \Illuminate\Database\Eloquent\Collection
    {
        return ChatbotMessage::where('conversation_id', $conversation->id)
            ->where('role', '!=', 'system')
            ->orderBy('created_at', 'asc')
            ->get();
    }

    /**
     * Build messages array from history
     *
     * @param \Illuminate\Database\Eloquent\Collection $messages
     * @param string $newUserMessage
     * @return array
     */
    protected function buildMessagesArray($messages, string $newUserMessage = ''): array
    {
        $messagesArray = [];

        // Add historical messages
        foreach ($messages as $message) {
            $messagesArray[] = [
                'role' => $message->role,
                'content' => $message->message,
                'created_at' => $message->created_at,
            ];
        }

        // Add new user message if provided
        if (!empty($newUserMessage)) {
            $messagesArray[] = [
                'role' => 'user',
                'content' => $newUserMessage,
                'created_at' => now(),
            ];
        }

        return $messagesArray;
    }

    /**
     * Optimize messages for token limits
     *
     * @param array $messages
     * @return array
     */
    protected function optimizeForTokens(array $messages): array
    {
        if (!$this->truncateOldMessages) {
            return $this->formatMessages($messages);
        }

        // Estimate tokens (rough estimate: 1 token ≈ 4 characters)
        $estimatedTokens = $this->estimateTokens($messages);

        if ($estimatedTokens <= $this->maxTokens) {
            return $this->formatMessages($messages);
        }

        // Need to truncate - keep most recent messages
        $truncated = $this->truncateMessages($messages);

        return $this->formatMessages($truncated);
    }

    /**
     * Estimate tokens for messages
     *
     * @param array $messages
     * @return int
     */
    protected function estimateTokens(array $messages): int
    {
        $totalChars = 0;

        foreach ($messages as $message) {
            $totalChars += strlen($message['content'] ?? '');
        }

        // Rough estimate: 1 token ≈ 4 characters
        return (int) ceil($totalChars / 4);
    }

    /**
     * Truncate messages to fit token limit
     *
     * @param array $messages
     * @return array
     */
    protected function truncateMessages(array $messages): array
    {
        // Keep most recent messages
        $reversed = array_reverse($messages);
        $kept = [];
        $currentTokens = 0;

        foreach ($reversed as $message) {
            $messageTokens = (int) ceil(strlen($message['content'] ?? '') / 4);
            
            if ($currentTokens + $messageTokens <= $this->maxTokens) {
                array_unshift($kept, $message);
                $currentTokens += $messageTokens;
            } else {
                break;
            }
        }

        // If we have space, try to keep at least one user-assistant pair
        if (empty($kept) && !empty($messages)) {
            $kept = [end($messages)];
        }

        return $kept;
    }

    /**
     * Format messages for OpenAI API
     *
     * @param array $messages
     * @return array
     */
    protected function formatMessages(array $messages): array
    {
        return array_map(function ($message) {
            return [
                'role' => $message['role'],
                'content' => $message['content'],
            ];
        }, $messages);
    }

    /**
     * Get system prompt for conversation
     *
     * @param ChatbotConversation $conversation
     * @return string
     */
    public function getSystemPrompt(ChatbotConversation $conversation): string
    {
        if (!config('chatbot.system_prompt.enabled', true)) {
            return '';
        }

        $customPrompt = config('chatbot.system_prompt.custom');
        if (!empty($customPrompt)) {
            return $this->replacePlaceholders($customPrompt, $conversation);
        }

        $template = config('chatbot.system_prompt.template', 'default');
        
        return $this->getSystemPromptTemplate($template, $conversation);
    }

    /**
     * Get system prompt template
     *
     * @param string $template
     * @param ChatbotConversation $conversation
     * @return string
     */
    protected function getSystemPromptTemplate(string $template, ChatbotConversation $conversation): string
    {
        $context = $conversation->context ?? [];

        $prompt = "You are a helpful assistant for The Strengths Toolbox, a company that provides strengths-based development, team building, and sales training services.

Your role is to:
- Answer questions about services, programs, and offerings
- Help visitors understand the benefits of strengths-based development
- Guide visitors to relevant pages or resources
- Provide information about booking consultations
- Be friendly, professional, and concise

Key information about The Strengths Toolbox:
- Services: Strengths-based development, team building, sales training, facilitation workshops
- Founder: Eberhard Niklaus
- Contact: {$context['contact']['phone'] ?? '+27 83 294 8033'}, {$context['contact']['email'] ?? 'welcome@eberhardniklaus.co.za'}
- Main offering: Build Strong Teams. Unlock Strong Profits.

If you don't know the answer to something, politely direct the user to contact the company directly or visit the contact page.";

        return $this->replacePlaceholders($prompt, $conversation);
    }

    /**
     * Replace placeholders in prompt
     *
     * @param string $prompt
     * @param ChatbotConversation $conversation
     * @return string
     */
    protected function replacePlaceholders(string $prompt, ChatbotConversation $conversation): string
    {
        $context = $conversation->context ?? [];
        $defaults = $this->getDefaultContext();

        $replacements = [
            '{company_name}' => $context['company'] ?? $defaults['company'] ?? 'The Strengths Toolbox',
            '{phone}' => $context['contact']['phone'] ?? $defaults['contact']['phone'] ?? '+27 83 294 8033',
            '{email}' => $context['contact']['email'] ?? $defaults['contact']['email'] ?? 'welcome@eberhardniklaus.co.za',
            '{services}' => implode(', ', $context['services'] ?? $defaults['services'] ?? []),
        ];

        return str_replace(array_keys($replacements), array_values($replacements), $prompt);
    }

    /**
     * Get default context
     *
     * @return array
     */
    protected function getDefaultContext(): array
    {
        return [
            'company' => 'The Strengths Toolbox',
            'services' => [
                'Strengths-based development',
                'Team building',
                'Sales training',
                'Facilitation workshops',
            ],
            'contact' => [
                'phone' => '+27 83 294 8033',
                'email' => 'welcome@eberhardniklaus.co.za',
            ],
        ];
    }

    /**
     * Clear context cache for conversation
     *
     * @param int $conversationId
     * @return void
     */
    public function clearContextCache(int $conversationId): void
    {
        Cache::forget("chatbot.context.{$conversationId}");
    }

    /**
     * Validate context messages
     *
     * @param array $messages
     * @return bool
     */
    public function validateContext(array $messages): bool
    {
        if (empty($messages)) {
            return false;
        }

        foreach ($messages as $message) {
            if (!isset($message['role']) || !isset($message['content'])) {
                return false;
            }

            $validRoles = ['user', 'assistant', 'system'];
            if (!in_array($message['role'], $validRoles)) {
                return false;
            }

            if (empty(trim($message['content']))) {
                return false;
            }
        }

        return true;
    }
}
```

#### Step 3: Update ChatbotService to Use Context Service

**File: `app/Services/ChatbotService.php`**

Update to use ChatbotContextService:

```php
<?php

namespace App\Services;

use App\Models\ChatbotConversation;
use App\Models\ChatbotMessage;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Cache;

class ChatbotService extends BaseService
{
    protected OpenAIClient $openAIClient;
    protected ChatbotContextService $contextService;
    protected int $maxContextMessages;
    protected int $conversationCacheTtl;

    public function __construct(OpenAIClient $openAIClient, ChatbotContextService $contextService)
    {
        $this->openAIClient = $openAIClient;
        $this->contextService = $contextService;
        $this->maxContextMessages = config('chatbot.max_context_messages', 10);
        $this->conversationCacheTtl = config('chatbot.cache_ttl', 3600);
    }

    /**
     * Send a message and get response
     *
     * @param int $conversationId
     * @param string $message
     * @return array
     */
    public function sendMessage(int $conversationId, string $message): array
    {
        try {
            $conversation = ChatbotConversation::findOrFail($conversationId);
            
            // Validate message
            $this->validateMessage($message);

            // Save user message
            $userMessage = $this->saveMessage(
                $conversationId,
                'user',
                $message
            );

            // Build context using context service
            $conversationHistory = $this->contextService->buildContext($conversation, $message);

            // Get system prompt
            $systemPrompt = $this->contextService->getSystemPrompt($conversation);

            // Build messages array for OpenAI
            $messages = $this->openAIClient->buildMessagesArray(
                $systemPrompt,
                $conversationHistory,
                $message
            );

            // Validate context
            if (!$this->contextService->validateContext($messages)) {
                throw new \RuntimeException('Invalid context generated');
            }

            // Call OpenAI API
            $aiResponse = $this->openAIClient->chatCompletion($messages);

            // Save AI response
            $aiMessage = $this->saveMessage(
                $conversationId,
                'assistant',
                $aiResponse['content'],
                $aiResponse['tokens_used']
            );

            // Clear context cache
            $this->contextService->clearContextCache($conversationId);

            // Update conversation context
            $this->updateConversationContext($conversation);

            Log::info('Chatbot message processed', [
                'conversation_id' => $conversationId,
                'user_message_id' => $userMessage->id,
                'ai_message_id' => $aiMessage->id,
                'tokens_used' => $aiResponse['tokens_used'],
                'context_messages' => count($conversationHistory),
            ]);

            return [
                'success' => true,
                'message' => $aiResponse['content'],
                'conversation_id' => $conversationId,
                'user_message_id' => $userMessage->id,
                'ai_message_id' => $aiMessage->id,
                'tokens_used' => $aiResponse['tokens_used'],
            ];
        } catch (\Exception $e) {
            // ... error handling ...
        }
    }

    /**
     * Get conversation context for OpenAI
     *
     * @param int $conversationId
     * @return array
     */
    public function getConversationContext(int $conversationId): array
    {
        $conversation = ChatbotConversation::findOrFail($conversationId);
        return $this->contextService->buildContext($conversation);
    }

    // ... rest of existing methods ...
}
```

## 5. Validation Steps

### 5.1 Code Validation

1. **Check ChatbotContextService exists:**
   ```bash
   test -f app/Services/ChatbotContextService.php && echo "Context service exists"
   ```

2. **Verify configuration:**
   ```bash
   php artisan tinker
   >>> config('chatbot.context.max_messages')
   ```

### 5.2 Functional Testing

1. **Test context building:**
   ```php
   $contextService = app(\App\Services\ChatbotContextService::class);
   $conversation = \App\Models\ChatbotConversation::first();
   $context = $contextService->buildContext($conversation);
   assert(is_array($context));
   ```

2. **Test token optimization:**
   ```php
   $messages = array_fill(0, 20, ['role' => 'user', 'content' => str_repeat('a', 1000)]);
   $optimized = $contextService->optimizeForTokens($messages);
   assert(count($optimized) <= 10);
   ```

## 6. Next Steps

After completing this task:
- **P7.1.4**: Add rate limiting
- **P7.1.5**: Implement comprehensive error handling

## 7. Notes

- Token estimation is approximate (1 token ≈ 4 characters)
- Context caching improves performance
- System prompts can be customized per conversation
- Old messages are truncated to fit token limits

---

**Document Version:** 1.0  
**Last Updated:** 2025-01-27  
**Status:** Ready for Implementation
